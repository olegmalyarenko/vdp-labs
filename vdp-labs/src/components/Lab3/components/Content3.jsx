import task from "../static/task3.png";
import schema from "../static/schema3.png";
import result from "../static/result3.png";
import factorial from "../static/faktorial.png";

const Content3 = () => (
    <div className="content" >
        <div className="content" id="meta3">
            <h3>Лабораторна робота №3</h3>
            <h4>Тема: Циклічні обчислювальні процеси</h4>
            <ul><h4>Мета роботи:</h4>
                <li>Вивчити особливості циклічних обчислювальних процесів</li>
                <li>Опанувати технологію використання операторів циклів</li>
                <li>Навчитися розробляти алгоритми та програми циклічних процесів</li>
            </ul>
        </div>

        <div className="content" id="task3">
            <h4>Варіант №17</h4>
            <h4>Умова завдання</h4>
            <p>Обчислити суму ряду, елемент котрого розраховується за формулою</p>
            <img src={task} alt="task"/>
        </div>

        <div className="content" id="analize3">
            <h4>Аналіз задачі, теоретичні обгрунтування вибраного методу вирішення задачі,<br/> розрахункові формули, посилання на літературні джерела.</h4>
            <p>Тому,що у цьому завданні у роботі з сумою ряду нам треба буде пройтися по числовому проміжку<br/> краще за все для цього підійде цикл з лічильником for.</p>
            <p>Для визначення факторіалу будемо використовувати таку формулу:</p>
            <img src={factorial} alt="factorial" width={300}/>
        </div>

        <div className="content" id="descr3">
            <h4>Опис алгоритму розв'язання задачі.</h4>
            <div>
            <ul>
                <li>Створюємо змінну k та задаємо їй значення</li>
                <li>Створюємо змінну result зі значенням 0</li>
                 <li>Створюємо змінну nomenator, щоб зберігати значення чисельника </li>
                <li> Йдемо циклом по доступним значенням х</li>
                <li> Для кожного можливого х проходимося по значенням k</li>
                <li> Для першого значення k чисельник вираховуємо по формулі x * (x + 1), а знаменик буде дорівнювати факторіалу k</li>
                <li> Значення дробу додаємо до result</li>
                <li>Наступні значення чисельник визначаємо, як (x + k) * x^k та додаємо до сумми чисельників nomenator,<br/>  знаменик як і раніше буде дорівнювати факторіалу k</li>
                <li>Після проходу всіх елементів циклу повертаємо значення result</li>
            </ul>
            </div>
        </div>
        
        <div className="content" id="schema3">
            <h4>Блок-схема алгоритму програми</h4>
            <img src={schema} alt="schema" width={500}/>
        </div>

        <div className="content" id="code3">
                <h4>Текст програми</h4>
                <div className="example"> 
                {` #include <iostream>`}<br/>
                {`#include <cmath>`}<br/>
                {`using namespace std;`}<br/>

                {`// Функція для визначення факторіалу`}<br/>
                {`int factorial(int i)`}<br/>
                {`{`}<br/>
                {`if (i == 0) return 1;`}<br/>
                {`else return i * factorial(i - 1);`}<br/>
                {`}`}<br/>

                {`int main()`}<br/>
                {`{`}<br/>
                {`int st_k = 20;// k від 0 до 20`}<br/>
                {`int result = 0;`}<br/>
                {`// Обчислення суми ряду`}<br/>
                {`for (int x = 1; x <= 5; x++) {`}<br/>
                {`int nomenator = 0;`}<br/>
                {`for (int k = 0; k < st_k; k++)`}<br/>
                {`{`}<br/>
                {`if (k == 0)`}<br/>
                {`{`}<br/>
                {`nomenator = x * (x + 1);`}<br/>
                {`int denomninator = factorial(k);`}<br/>
                {`result += nomenator / denomninator;`}<br/>
                {`continue;`}<br/>
                {`}`}<br/>
                {`nomenator += (x + k) * pow(x, k);`}<br/>
                {`int denomninator = factorial(k);`}<br/>
                {`result += nomenator / denomninator;`}<br/>
                {`}`}<br/>
                {`}`}<br/>
                {`// Вивід результату обчислень`}<br/>
                {`cout << "Result: " << result << endl;`}<br/>
                {`}`}<br/>
                </div>    
        </div>

        <div className="content" id="result3">
            <h4>Результати виконання програми</h4>
            <img src={result} alt="result" width={500} height={150}/><br/><br/>
        </div>

        <div className="content" id="summary3">
            <h4>Висновки</h4>
            <ul>Виконавши дану лабораторну роботу:
                <li>Вивчили особливості циклічних обчислювальних процесів та використали на практиці цикл з лічильником</li>
                <li>Розібралися з циклами з передумовою та постумовою</li>
                <li>Розробили алгоритм з двома вкладеними циклами</li>
            </ul>
        </div>

        <div className="content" id="answers3">
            <h4>Відповіді на контрольні питання</h4>
            <h5>У чому полягає відмінність між циклами з передумовою та циклами з постумовою?</h5>
            <p>Цикл із передумовою: спочатку перевіряється умова, потім, залежно від того, істинно воно або неправильно, або виконується тіло циклу, або випливає перехід до оператора,<br/> що випливає за тілом циклу. Після завершення тіла циклу керування знову передається на перевірку умови. Природно, передбачається, що в тілі циклу була забезпечена деяка зміна вхідних в умову змінних - а якщо ні, то відбудеться зациклення й програма "зависне".</p>

            <p>Цикл із після-умовою: спочатку виконується тіло циклу, потім керування передається на перевірку умови. Залежно від істинності або хибності умови, <br/> тіло циклу виконується повторно або ж відбувається перехід до оператора, що випливає за тілом циклу. Усі, сказане про можливе зациклення для циклу із передумовою, справедливо й для циклу з після- умовою.</p>
            <h5>Какому типу данных может принадлежать счетчик в цикле for? </h5>
            <p>Числовим типам даних.</p>
            <h5>Яке значення має лічильник після завершення циклу for?</h5>
            <p>На 1 більше останнього значення, для якого тіло циклу ще виконувалося</p>
            <h5>Що може спричинити «зациклення» програми?</h5>
            <p>Безкінченний цикл.</p>
            <h5>За яких умов цикли while та for не виконаються жодного разу?</h5>
            <p>Якщо умова в циклі одразу при першій перевірці приймає значення False, то тіло циклу не виконається жодного разу.</p>
            <h5>Коли цикл виконується лише один раз?</h5>
            <p>Перша ітерація після оголошення змінних, а далі якщо буде false;</p>
            <h5>У чому полягає відмінність між такими операторами циклів, як for, while, do … while?</h5>
            <p>У мові C++ цикл for може мати дуже широку реалізацію та застосування. Цикл for ще називається циклом з параметром.
                Цикл while називається циклом з передумовою.</p>
                <p>Цикл do … while доцільно використовувати у випадках, коли ітерацію потрібно зробити хоча б 1 раз. 
                    <br/>На відміну від циклів for та while, у циклі do…while умова перевіряється при виході з циклу (а не при вході в цикл).</p>
            <h5>Поясність алгоритм роботи вкладених циклів.</h5>     
            <p>Вкладені цикли організовані таким чином: внутрішній цикл повністю вміщується в тілі зовнішнього циклу.</p>   
            <h5>Якщо оператор break розміщується у внутрішньому циклі, то який цикл він перериває?</h5>
            <p>break перериває виконання лише одного циклу - того, що його безпосередньо викликає.</p>
            <h5>За яких умов слід обирати цикли for та while?</h5>
            <p>При виборі циклу необхідно оцінити необхідність перевірки умови при вході в цикл або після завершення проходження циклу.</p>
            <p>Цикл з умовою зручно застосовувати у випадках, коли для перевірки умови потрібно обчислити значення виразу, яке потім буде розміщено в тілі циклу </p>
            <p>Цикл з передумовою використовується у разі якщо всі змінні, що беруть участь у виразі, що перевіряє умову, проініціалізовані заздалегідь,<br/> але точне число повторень циклу невідоме або передбачається складна модифікація змінних, що беруть участь у формуванні умови повторення циклу.</p>
            <p>Якщо цикл орієнтований працювати з параметром,для якого заздалегідь відоме число повторень і крок зміни, більш кращим є параметричний цикл.<br/> Дуже зручно використовувати параметричний цикл під час роботи з масивами для перебору елементів</p>
        </div> 

   </div>
);

export default Content3;
 